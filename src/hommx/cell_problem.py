"""Helper problems that are used to solve the cell problem in the HMM.

Classes:
    PeriodicLinearProblem: linear problem class that automatically
    adds periodic boundary conditions on boxes.
"""

import dolfinx_mpc
import numpy as np
from dolfinx import fem
from dolfinx_mpc.assemble_matrix import assemble_matrix
from dolfinx_mpc.assemble_vector import apply_lifting, assemble_vector
from petsc4py import PETSc


class PeriodicLinearProblem(dolfinx_mpc.LinearProblem):
    """
    Class for solving a linear variational problem with periodic boundary conditions
    with multi point constraints of the form
    $a(u, v) = L(v)$ for all v using PETSc as a linear algebra backend.

    The solution is only unique up to a constant.
    This is handled by telling the PETSc KSP solver about the nullspace.

    Args:
        a: A bilinear UFL form, the left hand side of the variational problem.
        L: A linear UFL form, the right hand side of the variational problem.
        mpc: The multi point constraint.
        bcs: A list of Dirichlet boundary conditions.
        u: The solution function. It will be created if not provided. The function has
            to be based on the functionspace in the mpc, i.e.

            .. highlight:: python
            .. code-block:: python

                u = dolfinx.fem.Function(mpc.function_space)
        petsc_options: Parameters that is passed to the linear algebra backend PETSc.  #type: ignore
            For available choices for the 'petsc_options' kwarg, see the PETSc-documentation
            https://www.mcs.anl.gov/petsc/documentation/index.html.
        form_compiler_options: Parameters used in FFCx compilation of this form. Run `ffcx --help` at
            the commandline to see all available options. Takes priority over all
            other parameter values, except for `scalar_type` which is determined by DOLFINx.
        jit_options: Parameters used in CFFI JIT compilation of C code generated by FFCx.
            See https://github.com/FEniCS/dolfinx/blob/main/python/dolfinx/jit.py#L22-L37
            for all available parameters. Takes priority over all other parameter values.
    Examples:
        Example usage:

        .. highlight:: python
        .. code-block:: python

           problem = LinearProblem(
               a, L, mpc, [bc0, bc1], petsc_options={"ksp_type": "preonly", "pc_type": "lu"}
           )

    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        assert hasattr(self, "_A")
        comm = self._a.mesh.comm
        nullspace_vector = PETSc.Vec().create(comm)
        nullspace_vector.setSizes(self.A.getSize()[0])
        nullspace_vector.setUp()
        nullspace_vector.set(1.0)
        nullspace_vector.setValues(self._mpc.slaves, np.zeros_like(self._mpc.slaves))
        nullspace_vector.assemble()
        nullspace = PETSc.NullSpace().create(vectors=(nullspace_vector,), comm=comm)
        self._A.setNullSpace(nullspace)
        self._solver.setOperators(self._A)
        nullspace.remove(self._b)
        self._nullspace = nullspace

    def solve(self) -> fem.Function:
        """Solve the problem."""

        # Assemble lhs
        self._A.zeroEntries()
        assemble_matrix(self._a, self._mpc, bcs=self.bcs, A=self._A)
        self._A.assemble()
        assert self._A.assembled

        # Assemble rhs
        with self._b.localForm() as b_loc:
            b_loc.set(0)
        assemble_vector(self._L, self._mpc, b=self._b)

        # Apply boundary conditions to the rhs
        apply_lifting(self._b, [self._a], [self.bcs], self._mpc)
        self._b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)  # type: ignore
        fem.petsc.set_bc(self._b, self.bcs)

        self._nullspace.remove(self._b)
        # Solve linear system and update ghost values in the solution
        self._solver.solve(self._b, self._x)
        self.u.x.scatter_forward()
        self._mpc.backsubstitution(self.u)

        return self.u
